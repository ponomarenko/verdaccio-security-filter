import * as fs from 'fs';
import * as path from 'path';
import { CVECheckConfig, CVECheckResult, CVEVulnerability } from '../types';

/**
 * CVE Checker that integrates with vulnerability databases
 */
export class CVEChecker {
    private config: CVECheckConfig;
    private cache: Map<string, CVECheckResult> = new Map();
    private lastUpdate: number = 0;

    constructor(config?: CVECheckConfig) {
        this.config = {
            enabled: config?.enabled || false,
            databases: config?.databases || ['osv'],
            severity: config?.severity || ['high', 'critical'],
            autoBlock: config?.autoBlock || false,
            updateInterval: config?.updateInterval || 24,
            cacheDir: config?.cacheDir || './.security-cache',
        };

        if (this.config.enabled) {
            this.loadCache();
        }
    }

    /**
     * Check if a package version has known vulnerabilities
     */
    async checkPackage(packageName: string, version: string): Promise<CVECheckResult> {
        if (!this.config.enabled) {
            return {
                package: packageName,
                version,
                vulnerabilities: [],
                isVulnerable: false,
                checkedAt: new Date().toISOString(),
            };
        }

        const cacheKey = `${packageName}@${version}`;

        // Check cache first
        if (this.cache.has(cacheKey) && !this.isCacheStale()) {
            return this.cache.get(cacheKey)!;
        }

        // Fetch from databases
        const vulnerabilities = await this.fetchVulnerabilities(packageName, version);

        // Filter by configured severity
        const filteredVulnerabilities = vulnerabilities.filter(vuln =>
            this.config.severity.includes(vuln.severity)
        );

        const result: CVECheckResult = {
            package: packageName,
            version,
            vulnerabilities: filteredVulnerabilities,
            isVulnerable: filteredVulnerabilities.length > 0,
            checkedAt: new Date().toISOString(),
        };

        // Cache result
        this.cache.set(cacheKey, result);
        this.saveCache();

        return result;
    }

    /**
     * Fetch vulnerabilities from configured databases
     */
    private async fetchVulnerabilities(packageName: string, version: string): Promise<CVEVulnerability[]> {
        const vulnerabilities: CVEVulnerability[] = [];

        for (const database of this.config.databases) {
            try {
                switch (database) {
                    case 'osv':
                        vulnerabilities.push(...await this.fetchFromOSV(packageName, version));
                        break;
                    case 'snyk':
                        // Snyk integration would go here (requires API key)
                        break;
                    case 'github':
                        // GitHub Advisory Database integration would go here
                        break;
                }
            } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                console.error(`[CVE Checker] Error fetching from ${database}:`, message);
            }
        }

        return vulnerabilities;
    }

    /**
     * Fetch vulnerabilities from OSV (Open Source Vulnerabilities) database
     * https://osv.dev/
     */
    private async fetchFromOSV(packageName: string, version: string): Promise<CVEVulnerability[]> {
        const maxRetries = 3;
        const retryDelay = 1000;

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);

                const response = await fetch('https://api.osv.dev/v1/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        package: {
                            name: packageName,
                            ecosystem: 'npm',
                        },
                        version: version,
                    }),
                    signal: controller.signal,
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    if (response.status === 429 && attempt < maxRetries) {
                        const waitTime = retryDelay * Math.pow(2, attempt - 1);
                        console.warn(`[CVE Checker] Rate limited, retrying in ${waitTime}ms (attempt ${attempt}/${maxRetries})`);
                        await this.sleep(waitTime);
                        continue;
                    }
                    throw new Error(`OSV API returned ${response.status}`);
                }

                const data = await response.json();

                if (!data.vulns || data.vulns.length === 0) {
                    return [];
                }

                return data.vulns.map((vuln: any) => ({
                    id: vuln.id,
                    severity: this.mapOSVSeverity(vuln.severity),
                    summary: vuln.summary || vuln.details || 'No description available',
                    affectedVersions: vuln.affected?.map((a: any) => a.ranges?.map((r: any) => r.events?.map((e: any) => e.introduced || e.fixed).filter(Boolean)).flat()).flat() || [],
                    fixedVersion: vuln.affected?.[0]?.ranges?.[0]?.events?.find((e: any) => e.fixed)?.fixed,
                    publishedDate: vuln.published || new Date().toISOString(),
                    source: 'osv',
                }));
            } catch (error) {
                const message = error instanceof Error ? error.message : String(error);

                if (attempt === maxRetries) {
                    console.error(`[CVE Checker] OSV API error after ${maxRetries} attempts:`, message);
                    return [];
                }

                if (error instanceof Error && error.name === 'AbortError') {
                    console.warn(`[CVE Checker] Request timeout, retrying (attempt ${attempt}/${maxRetries})`);
                } else {
                    console.warn(`[CVE Checker] Request failed, retrying (attempt ${attempt}/${maxRetries}):`, message);
                }

                await this.sleep(retryDelay * attempt);
            }
        }

        return [];
    }

    /**
     * Sleep utility for retry delays
     */
    private sleep(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * Map OSV severity to our severity levels
     */
    private mapOSVSeverity(osvSeverity: any): 'low' | 'medium' | 'high' | 'critical' {
        if (!osvSeverity || osvSeverity.length === 0) {
            return 'medium';
        }

        // OSV uses CVSS scores
        const severity = osvSeverity[0];
        if (severity.type === 'CVSS_V3') {
            const score = parseFloat(severity.score);
            if (score >= 9.0) return 'critical';
            if (score >= 7.0) return 'high';
            if (score >= 4.0) return 'medium';
            return 'low';
        }

        return 'medium';
    }

    /**
     * Check if cache is stale
     */
    private isCacheStale(): boolean {
        const now = Date.now();
        const updateIntervalMs = this.config.updateInterval! * 60 * 60 * 1000;
        return now - this.lastUpdate > updateIntervalMs;
    }

    /**
     * Load cache from disk
     */
    private loadCache(): void {
        try {
            const cacheFile = path.join(this.config.cacheDir!, 'cve-cache.json');
            if (fs.existsSync(cacheFile)) {
                const data = fs.readFileSync(cacheFile, 'utf8');
                const parsed = JSON.parse(data);
                this.cache = new Map(Object.entries(parsed.cache));
                this.lastUpdate = parsed.lastUpdate || 0;
            }
        } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            console.error('[CVE Checker] Failed to load cache:', message);
        }
    }

    /**
     * Save cache to disk
     */
    private saveCache(): void {
        try {
            const cacheFile = path.join(this.config.cacheDir!, 'cve-cache.json');
            const dir = path.dirname(cacheFile);

            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }

            const data = {
                cache: Object.fromEntries(this.cache),
                lastUpdate: Date.now(),
            };

            fs.writeFileSync(cacheFile, JSON.stringify(data, null, 2), 'utf8');
            this.lastUpdate = Date.now();
        } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            console.error('[CVE Checker] Failed to save cache:', message);
        }
    }

    /**
     * Clear cache
     */
    clearCache(): void {
        this.cache.clear();
        this.lastUpdate = 0;
        this.saveCache();
    }
}
